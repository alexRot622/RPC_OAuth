/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "auth.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

char *status_string(oauth_status status);

void
checkprog_1(char *host, char *filename)
{
	CLIENT *clnt;
	void *result;
	char *request_auth;
	s_req_token request_token;

#ifndef	DEBUG
	clnt = clnt_create (host, CHECKPROG, CHECKVERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

    FILE *file = fopen(filename, "r");
    if (!file) {
        fprintf(stderr, "%s not found\n", filename);
        return;
    }

    char line[256];
    char *token;

    char **users = calloc(256, sizeof(char *));
    char **accessTokens = calloc(256, sizeof(char *));
    char **refreshTokens = calloc(256, sizeof(char *));
    int nUsers = 0;

    while (fgets(line, 256, file)) {
        token = strtok(line, ",\n");
        char *user_id = calloc(strlen(token) + 1, 1);
        strncpy(user_id, token, strlen(token));

        token = strtok(NULL, ",\n");
        char *command = calloc(strlen(token) + 1, 1);
        strncpy(command, token, strlen(token));

        token = strtok(NULL, ",\n");
        char *arg = calloc(strlen(token) + 1, 1);
        strncpy(arg, token, strlen(token));

        if (strcmp(command, "REQUEST") == 0) {
            if (strcmp(arg, "0") == 0) {
                request_token.refresh = 0;
            }
            else if (strcmp(arg, "1") == 0) {
                request_token.refresh = 1;
            }
            else {
                // TODO: PRINT ERROR
            }

            request_auth = user_id;
            result = request_auth_1(&request_auth, clnt);
            if (result == (oauth_response *) NULL) {
                fprintf(stderr, "RESULT NULL\n");
                clnt_perror(clnt, "call failed");
                continue;
            }

            oauth_response *response = (oauth_response *) (result);
            if (response->status) {
                printf("%s\n", status_string(response->status));
                continue;
            }

            char **signed_token = approve_token_1(&response->requestToken, clnt);
            if (strcmp(response->requestToken, *signed_token) == 0) {
                // TODO: print not signed or smth
                continue;
            }

            request_token.token = *signed_token;
            request_token.id = user_id;

            response = request_token_1(&request_token, clnt);
            if (response == NULL) {
                clnt_perror(clnt, "call failed");
            }

            if (response->status) {
                printf("%s\n", status_string(response->status));
                continue;
            }

            int pos = -1;
            for (int i = 0; i < nUsers && pos < 0; i++) {
                if (strcmp(users[i], user_id) == 0) {
                    pos = i;
                }
            }

            if (pos < 0) {
                pos = nUsers;
                nUsers++;
            }
            if (!users[pos])
                users[pos] = calloc(32, 1);
            strcpy(users[pos], user_id);

            if (!accessTokens[pos])
                accessTokens[pos] = calloc(32, 1);
            strcpy(accessTokens[pos], response->accessToken);

            if (request_token.refresh) {
                if (!refreshTokens[pos])
                    refreshTokens[pos] = calloc(32, 1);
                strcpy(refreshTokens[pos], response->refreshToken);
            }

            printf("%s -> %s", user_id, response->accessToken);
            if (request_token.refresh) {
                printf(",%s", response->refreshToken);
            }
            printf("\n");
        }
        else {
            // Operation
            action act;
            if (strcmp(command, "READ") == 0) {
                act = READ;
            }
            else if (strcmp(command, "INSERT") == 0) {
                act = INSERT;
            }
            else if (strcmp(command, "MODIFY") == 0) {
                act = MODIFY;
            }
            else if (strcmp(command, "DELETE") == 0) {
                act = DELETE;
            }
            else if (strcmp(command, "EXECUTE") == 0) {
                act = EXECUTE;
            }
            else {
                // TODO: PRINT ERROR
                break;
            }

            request_token.act.act = act;
            request_token.act.token = NULL;
            request_token.act.resource = arg;
            for (int i = 0; i < nUsers && !request_token.act.token; i++) {
                if (strcmp(users[i], user_id) == 0)
                    request_token.act.token = accessTokens[i];
            }

            if (!request_token.act.token) {
                // TODO: print error
                continue;
            }

            result = validate_action_1(&request_token, clnt);
            if (result == (oauth_response *) NULL) {
                clnt_perror(clnt, "call failed");
            }

            oauth_response *response = (oauth_response *) (result);
            printf("%s\n", status_string(response->status));
        }
    }

    for (int i = 0; i < nUsers; i++) {
        if (users[i])
            free(users[i]);
        if (accessTokens[i])
            free(accessTokens[i]);
        if (refreshTokens[i])
            free(refreshTokens[i]);
    }
    free(users);
    free(accessTokens);
    free(refreshTokens);

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}

char *status_string(oauth_status status) {
    switch (status) {
        case PERMISSION_GRANTED: {
            return "PERMISSION_GRANTED";
        }
        case USER_NOT_FOUND: {
            return "USER_NOT_FOUND";
        }
        case REQUEST_DENIED: {
            return "REQUEST_DENIED";
        }
        case PERMISSION_DENIED: {
            return "PERMISSION_DENIED";
        }
        case TOKEN_EXPIRED: {
            return "TOKEN_EXPIRED";
        }
        case RESOURCE_NOT_FOUND: {
            return "RESOURCE_NOT_FOUND";
        }
        case OPERATION_NOT_PERMITTED: {
            return "OPERATION_NOT_PERMITTED";
        }
        default:
            return NULL;
    }
}

int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 3) {
		printf ("usage: %s server_host client_input\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	checkprog_1(host, argv[2]);
exit (0);
}
